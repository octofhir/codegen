use crate::core::Result;
use crate::languages::typescript::backend::TypeScriptBackend;
use serde_json::json;

/// Configuration for package manifest generation
#[derive(Debug, Clone)]
pub struct PackageConfig {
    /// Package name (e.g., "@octofhir/fhir-r4")
    pub name: String,
    /// Package version
    pub version: String,
    /// Package description
    pub description: String,
    /// FHIR version (e.g., "R4", "R5")
    pub fhir_version: String,
    /// Repository URL
    pub repository_url: Option<String>,
    /// License
    pub license: String,
}

impl Default for PackageConfig {
    fn default() -> Self {
        Self {
            name: "@octofhir/fhir-r4".to_string(),
            version: "4.0.1".to_string(),
            description: "Type-safe FHIR R4 SDK generated by OctoFHIR Codegen".to_string(),
            fhir_version: "R4".to_string(),
            repository_url: Some("https://github.com/octofhir/fhir-sdk-typescript".to_string()),
            license: "Apache-2.0".to_string(),
        }
    }
}

/// Generator for TypeScript package manifests
#[allow(dead_code)]
pub struct ManifestGenerator {
    backend: TypeScriptBackend,
    config: PackageConfig,
}

impl ManifestGenerator {
    /// Create a new manifest generator
    pub fn new(backend: TypeScriptBackend, config: PackageConfig) -> Self {
        Self { backend, config }
    }

    /// Create with default configuration
    pub fn with_defaults(backend: TypeScriptBackend) -> Self {
        Self::new(backend, PackageConfig::default())
    }

    /// Generate package.json
    pub fn generate_package_json(&self) -> Result<String> {
        let mut package = json!({
            "name": self.config.name,
            "version": self.config.version,
            "description": self.config.description,
            "type": "module",
            "main": "./dist/index.js",
            "types": "./dist/index.d.ts",
            "exports": {
                ".": {
                    "types": "./dist/index.d.ts",
                    "default": "./dist/index.js"
                },
                "./types/*": {
                    "types": "./dist/types/*.d.ts",
                    "default": "./dist/types/*.js"
                }
            },
            "sideEffects": false,
            "scripts": {
                "build": "tsc",
                "test": "vitest",
                "lint": "biome check .",
                "format": "biome format --write .",
                "typecheck": "tsc --noEmit"
            },
            "keywords": [
                "fhir",
                self.config.fhir_version.to_lowercase(),
                "healthcare",
                "hl7",
                "typescript",
                "types",
                "octofhir"
            ],
            "license": self.config.license,
            "devDependencies": {
                "@types/node": "^20.0.0",
                "typescript": "^5.8.0",
                "vitest": "^2.0.0",
                "@biomejs/biome": "^1.9.0"
            },
            "engines": {
                "node": ">=18.0.0"
            }
        });

        if let Some(repo_url) = &self.config.repository_url {
            package["repository"] = json!({
                "type": "git",
                "url": repo_url
            });
        }

        serde_json::to_string_pretty(&package).map_err(|e| {
            crate::core::Error::Generator(format!("Failed to serialize package.json: {}", e))
        })
    }

    /// Generate tsconfig.json for ESM
    pub fn generate_tsconfig_json(&self) -> Result<String> {
        let tsconfig = json!({
            "compilerOptions": {
                "target": "ES2022",
                "module": "ESNext",
                "lib": ["ES2022"],
                "moduleResolution": "bundler",
                "declaration": true,
                "declarationMap": true,
                "sourceMap": true,
                "outDir": "./dist",
                "rootDir": "./src",
                "strict": true,
                "esModuleInterop": true,
                "skipLibCheck": true,
                "forceConsistentCasingInFileNames": true,
                "resolveJsonModule": true,
                "isolatedModules": true,
                "noUncheckedIndexedAccess": true,
                "noUnusedLocals": true,
                "noUnusedParameters": true,
                "noImplicitReturns": true,
                "noFallthroughCasesInSwitch": true
            },
            "include": ["src/**/*"],
            "exclude": ["node_modules", "dist", "**/*.test.ts"]
        });

        serde_json::to_string_pretty(&tsconfig).map_err(|e| {
            crate::core::Error::Generator(format!("Failed to serialize tsconfig.json: {}", e))
        })
    }


    /// Generate README.md
    pub fn generate_readme(&self) -> Result<String> {
        let readme = format!(
            r#"# {}

{}

**Generated by [OctoFHIR Codegen](https://github.com/octofhir/codegen)**

## Installation

```bash
npm install {}
```

## Features

- ✅ **Type-safe** - Full TypeScript types for all FHIR {} resources
- ✅ **Validation** - Runtime validation functions for all resources
- ✅ **Helper methods** - Convenient utility functions for common operations
- ✅ **Choice elements** - Discriminated unions for FHIR choice types
- ✅ **Tree-shakeable** - Import only what you need
- ✅ **Strict mode** - Built with TypeScript strict mode enabled

## Usage

### Basic Example

```typescript
import {{ Patient, validatePatient, PatientHelpers }} from '{}';

// Create a patient
const patient: Patient = {{
  resourceType: 'Patient',
  id: '123',
  active: true,
  name: [
    {{
      use: 'official',
      family: 'Doe',
      given: ['John']
    }}
  ],
  gender: 'male',
  birthDate: '1974-12-25'
}};

// Validate the patient
const validation = validatePatient(patient);
if (!validation.valid) {{
  console.error('Validation errors:', validation.errors);
}}

// Use helper methods
const fullName = PatientHelpers.getFullName(patient);
const age = PatientHelpers.getAge(patient);
console.log(`${{fullName}} is ${{age}} years old`);
```

### Working with Observations

```typescript
import {{ Observation, validateObservation, ObservationHelpers }} from '{}';

const observation: Observation = {{
  resourceType: 'Observation',
  status: 'final',
  code: {{
    coding: [
      {{
        system: 'http://loinc.org',
        code: '85354-9',
        display: 'Blood pressure'
      }}
    ]
  }},
  valueQuantity: {{
    value: 120,
    unit: 'mmHg',
    system: 'http://unitsofmeasure.org',
    code: 'mm[Hg]'
  }}
}};

// Validate
const result = validateObservation(observation);

// Get value
const value = ObservationHelpers.getValue(observation);
```

### Choice Elements

FHIR choice elements (e.g., `value[x]`) are represented as discriminated unions:

```typescript
import {{ ObservationValueChoice }} from '{}/types';

const choice: ObservationValueChoice =
  | {{ valueString: "Normal" }}
  | {{ valueQuantity: {{ value: 120, unit: "mmHg" }} }}
  | {{ valueBoolean: true }};
```

## API Reference

### Resources

All FHIR {} resources are available as TypeScript interfaces:

- `Patient`
- `Observation`
- `Condition`
- `Medication`
- And many more...

### Validation

Each resource has a corresponding validation function:

```typescript
validatePatient(patient: Patient): ValidationResult
validateObservation(obs: Observation): ValidationResult
// ... etc
```

### Helpers

Resource-specific helper namespaces:

- `PatientHelpers` - Patient utility functions
- `ObservationHelpers` - Observation utility functions

### Utilities

- `extractPrimitiveValue<T>()` - Extract value from `FhirPrimitive<T>` wrapper

## Development

```bash
# Install dependencies
npm install

# Build
npm run build

# Run tests
npm test

# Lint
npm run lint

# Format
npm run format
```

## License

{}

## Generated

This package was automatically generated by OctoFHIR Codegen.

- FHIR Version: {}
- Generated: {}
"#,
            self.config.name,
            self.config.description,
            self.config.name,
            self.config.fhir_version,
            self.config.name,
            self.config.name,
            self.config.name,
            self.config.fhir_version,
            self.config.license,
            self.config.fhir_version,
            chrono::Utc::now().format("%Y-%m-%d")
        );

        Ok(readme)
    }

    /// Generate .gitignore
    pub fn generate_gitignore(&self) -> Result<String> {
        Ok(r#"# Dependencies
node_modules/
package-lock.json
yarn.lock
pnpm-lock.yaml

# Build output
dist/
*.tsbuildinfo

# Test coverage
coverage/

# Environment
.env
.env.local

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db

# Logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
"#
        .to_string())
    }

    /// Generate .npmignore
    pub fn generate_npmignore(&self) -> Result<String> {
        Ok(r#"# Source files
src/
tsconfig.json
biome.json

# Tests
*.test.ts
**/*.test.ts
coverage/

# Development
.vscode/
.idea/
*.swp

# Build
*.tsbuildinfo

# Git
.git/
.gitignore
"#
        .to_string())
    }

    /// Generate biome.json configuration
    pub fn generate_biome_json(&self) -> Result<String> {
        let biome = json!({
            "$schema": "https://biomejs.dev/schemas/1.9.0/schema.json",
            "organizeImports": {
                "enabled": true
            },
            "linter": {
                "enabled": true,
                "rules": {
                    "recommended": true,
                    "suspicious": {
                        "noExplicitAny": "warn"
                    },
                    "style": {
                        "useConst": "error",
                        "noParameterAssign": "warn"
                    }
                }
            },
            "formatter": {
                "enabled": true,
                "formatWithErrors": false,
                "indentStyle": "space",
                "indentWidth": 2,
                "lineWidth": 100,
                "lineEnding": "lf"
            },
            "javascript": {
                "formatter": {
                    "quoteStyle": "single",
                    "trailingCommas": "es5",
                    "semicolons": "always",
                    "arrowParentheses": "always"
                }
            }
        });

        serde_json::to_string_pretty(&biome)
            .map_err(|e| crate::core::Error::Generator(format!("Failed to serialize biome.json: {}", e)))
    }
}
